// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"d": {
		"index.js": function (exports, module, require) {
			'use strict';

			var assign        = require('es5-ext/object/assign')
			  , normalizeOpts = require('es5-ext/object/normalize-options')
			  , isCallable    = require('es5-ext/object/is-callable')
			  , contains      = require('es5-ext/string/#/contains')

			  , d;

			d = module.exports = function (dscr, value/*, options*/) {
				var c, e, w, options, desc;
				if ((arguments.length < 2) || (typeof dscr !== 'string')) {
					options = value;
					value = dscr;
					dscr = null;
				} else {
					options = arguments[2];
				}
				if (dscr == null) {
					c = w = true;
					e = false;
				} else {
					c = contains.call(dscr, 'c');
					e = contains.call(dscr, 'e');
					w = contains.call(dscr, 'w');
				}

				desc = { value: value, configurable: c, enumerable: e, writable: w };
				return !options ? desc : assign(normalizeOpts(options), desc);
			};

			d.gs = function (dscr, get, set/*, options*/) {
				var c, e, options, desc;
				if (typeof dscr !== 'string') {
					options = set;
					set = get;
					get = dscr;
					dscr = null;
				} else {
					options = arguments[3];
				}
				if (get == null) {
					get = undefined;
				} else if (!isCallable(get)) {
					options = get;
					get = set = undefined;
				} else if (set == null) {
					set = undefined;
				} else if (!isCallable(set)) {
					options = set;
					set = undefined;
				}
				if (dscr == null) {
					c = true;
					e = false;
				} else {
					c = contains.call(dscr, 'c');
					e = contains.call(dscr, 'e');
				}

				desc = { get: get, set: set, configurable: c, enumerable: e };
				return !options ? desc : assign(normalizeOpts(options), desc);
			};
		}
	},
	"deferred": {
		"_ext.js": function (exports, module, require) {
			"use strict";
			
			var callable   = require("es5-ext/object/valid-callable")
			  , isCallable = require("es5-ext/object/is-callable")
			  , isValue    = require("es5-ext/object/is-value")
			  , d          = require("d")
			  , ee         = require("event-emitter")
			  , isPromise  = require("./is-promise");
			
			var create = Object.create, defineProperty = Object.defineProperty, deferred, resolve, reject;
			
			module.exports = exports = function (name, unres, onres, res) {
				name = String(name);
				callable(res);
				if (isValue(onres)) callable(onres);
				callable(unres);
				defineProperty(exports._unresolved, name, d(unres));
				exports._onresolve[name] = onres;
				defineProperty(exports._resolved, name, d(res));
				exports._names.push(name);
			};
			
			exports._names = ["done", "then", "valueOf"];
			
			exports._unresolved = ee(
				create(Function.prototype, {
					then: d(function (win, fail) {
						var def;
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push("then", [win, fail, def.resolve, def.reject]);
						return def.promise;
					}),
					done: d(function (win, fail) {
						if (isValue(win)) callable(win);
						if (isValue(fail)) callable(fail);
						if (!this.pending) this.pending = [];
						this.pending.push("done", arguments);
					}),
					resolved: d(false),
					returnsPromise: d(true),
					valueOf: d(function () {
						return this;
					})
				})
			);
			
			exports._onresolve = {
				then: function (win, fail, promiseResolve, promiseReject) {
					var value, cont = this.failed ? fail : win;
					if (!isValue(cont)) {
						if (this.failed) promiseReject(this.value);
						else promiseResolve(this.value);
						return;
					}
					if (isCallable(cont)) {
						if (isPromise(cont)) {
							if (cont.resolved) {
								if (cont.failed) promiseReject(cont.value);
								else promiseResolve(cont.value);
								return;
							}
							cont.done(promiseResolve, promiseReject);
							return;
						}
						try {
							value = cont(this.value);
						} catch (e) {
							promiseReject(e);
							return;
						}
						promiseResolve(value);
						return;
					}
					promiseResolve(cont);
				},
				done: function (win, fail) {
					if (this.failed) {
						if (fail) {
							fail(this.value);
							return;
						}
						throw this.value;
					}
					if (win) win(this.value);
				}
			};
			
			exports._resolved = ee(
				create(Function.prototype, {
					then: d(function (win, fail) {
						var value, cont = this.failed ? fail : win;
						if (!isValue(cont)) return this;
						if (isCallable(cont)) {
							if (isPromise(cont)) return cont;
							try {
								value = cont(this.value);
							} catch (e) {
								return reject(e);
							}
							return resolve(value);
						}
						return resolve(cont);
					}),
					done: d(function (win, fail) {
						if (isValue(win)) callable(win);
						if (isValue(fail)) callable(fail);
						if (this.failed) {
							if (fail) {
								fail(this.value);
								return;
							}
							throw this.value;
						}
						if (win) win(this.value);
					}),
					resolved: d(true),
					returnsPromise: d(true),
					valueOf: d(function () {
						return this.value;
					})
				})
			);
			
			deferred = require("./deferred");
			resolve = deferred.resolve;
			reject = deferred.reject;
			deferred.extend = exports;
		},
		"assimilate.js": function (exports, module, require) {
			// Assimilate eventual foreign promise
			
			"use strict";
			
			var isObject  = require("es5-ext/object/is-object")
			  , isPromise = require("./is-promise")
			  , deferred  = require("./deferred")
			  , nextTick  = require("next-tick");
			
			var getPrototypeOf = Object.getPrototypeOf;
			
			module.exports = function self(value) {
				var then, done, def, resolve, reject;
				if (!value) return value;
				try {
					then = value.then;
				} catch (e) {
					return value;
				}
				if (typeof then !== "function") return value;
				if (isPromise(value)) return value;
				if (!isObject(value)) return value;
				if (!getPrototypeOf(value)) return value;
				try {
					done = value.done;
				} catch (ignore) {}
				def = deferred();
				resolve = function (resolvedValue) {
					def.resolve(self(resolvedValue));
				};
				reject = function (resolvedReason) {
					def.reject(resolvedReason);
				};
				if (typeof done === "function") {
					try {
						done.call(value, resolve, reject);
					} catch (e) {
						return def.reject(e);
					}
					return def.promise;
				}
				try {
					then.call(
						value,
						function (resolvedValue) {
							nextTick(function () {
								resolve(resolvedValue);
							});
						},
						function (resolvedReason) {
							nextTick(function () {
								reject(resolvedReason);
							});
						}
					);
				} catch (e) {
					return def.reject(e);
				}
				return def.promise;
			};
		},
		"deferred.js": function (exports, module, require) {
			/* eslint max-statements: "off", max-depth: "off" */
			
			// Returns function that returns deferred or promise object.
			//
			// 1. If invoked without arguments then deferred object is returned
			//    Deferred object consist of promise (unresolved) function and resolve
			//    function through which we resolve promise
			// 2. If invoked with one argument then promise is returned which resolved value
			//    is given argument. Argument may be any value (even undefined),
			//    if it's promise then same promise is returned
			// 3. If invoked with more than one arguments then promise that resolves with
			//    array of all resolved arguments is returned.
			
			"use strict";
			
			var isError        = require("es5-ext/error/is-error")
			  , noop           = require("es5-ext/function/noop")
			  , setPrototypeOf = require("es5-ext/object/set-prototype-of")
			  , isPromise      = require("./is-promise");
			
			var every = Array.prototype.every
			  , push = Array.prototype.push
			  , getPrototypeOf = Object.getPrototypeOf
			  , Deferred
			  , createDeferred
			  , count = 0
			  , timeout
			  , extendShim
			  , ext
			  , resolve
			  , assimilate;
			
			extendShim = function (promise) {
				ext._names.forEach(function (name) {
					promise[name] = function () {
						return getPrototypeOf(promise)[name].apply(promise, arguments);
					};
				});
				promise.returnsPromise = true;
				promise.resolved = getPrototypeOf(promise).resolved;
			};
			
			resolve = function (value, failed) {
				var promise = function (win, fail) {
					return promise.then(win, fail);
				};
				promise.value = value;
				promise.failed = failed;
				if (setPrototypeOf) setPrototypeOf(promise, ext._resolved);
				else extendShim(promise);
				if (createDeferred._profile) createDeferred._profile(true);
				return promise;
			};
			
			Deferred = function () {
				var promise = function (win, fail) {
					return promise.then(win, fail);
				};
				if (!count) timeout = setTimeout(noop, 1e9);
				++count;
				if (createDeferred._monitor) promise.monitor = createDeferred._monitor();
				if (setPrototypeOf) setPrototypeOf(promise, ext._unresolved);
				else extendShim(promise);
				if (createDeferred._profile) createDeferred._profile();
				this.promise = promise;
				this.resolve = this.resolve.bind(this);
				this.reject = this.reject.bind(this);
			};
			
			Deferred.prototype = {
				resolved: false,
				_settle: function (value) {
					var i, name, data, deps, dPromise, nuDeps;
					this.promise.value = value;
					if (setPrototypeOf) setPrototypeOf(this.promise, ext._resolved);
					else this.promise.resolved = true;
					deps = this.promise.dependencies;
					delete this.promise.dependencies;
					while (deps) {
						for (i = 0; (dPromise = deps[i]); ++i) {
							dPromise.value = value;
							dPromise.failed = this.failed;
							if (setPrototypeOf) setPrototypeOf(dPromise, ext._resolved);
							else dPromise.resolved = true;
							delete dPromise.pending;
							if (dPromise.dependencies) {
								if (nuDeps) push.apply(nuDeps, dPromise.dependencies);
								else nuDeps = dPromise.dependencies;
								delete dPromise.dependencies;
							}
						}
						deps = nuDeps;
						nuDeps = null;
					}
					if ((data = this.promise.pending)) {
						for (i = 0; (name = data[i]); ++i) {
							ext._onresolve[name].apply(this.promise, data[++i]);
						}
						delete this.promise.pending;
					}
					return this.promise;
				},
				resolve: function (value) {
					if (this.resolved) return this.promise;
					this.resolved = true;
					if (!--count) clearTimeout(timeout);
					if (this.promise.monitor) clearTimeout(this.promise.monitor);
					value = assimilate(value);
					if (isPromise(value)) {
						if (!value.resolved) {
							if (!value.dependencies) {
								value.dependencies = [];
							}
							value.dependencies.push(this.promise);
							if (this.promise.pending) {
								if (value.pending) {
									this.promise.pending.forEach(function (promise) {
										value.pending.push(promise);
									});
									this.promise.pending = value.pending;
									if (this.promise.dependencies) {
										this.promise.dependencies.forEach(function self(dPromise) {
											dPromise.pending = value.pending;
											if (dPromise.dependencies) {
												dPromise.dependencies.forEach(self);
											}
										});
									}
								} else {
									value.pending = this.promise.pending;
								}
							} else if (value.pending) {
								this.promise.pending = value.pending;
							} else {
								this.promise.pending = value.pending = [];
							}
							return this.promise;
						}
						this.promise.failed = value.failed;
						value = value.value;
					}
					return this._settle(value);
				},
				reject: function (error) {
					if (this.resolved) return this.promise;
					this.resolved = true;
					if (!--count) clearTimeout(timeout);
					if (this.promise.monitor) clearTimeout(this.promise.monitor);
					this.promise.failed = true;
					return this._settle(error);
				}
			};
			
			module.exports = createDeferred = function (value) {
				var length = arguments.length, d, waiting, initialized, result;
				if (!length) return new Deferred();
				if (length > 1) {
					d = new Deferred();
					waiting = 0;
					result = new Array(length);
					every.call(arguments, function (itemValue, index) {
						itemValue = assimilate(itemValue);
						if (!isPromise(itemValue)) {
							result[index] = itemValue;
							return true;
						}
						if (itemValue.resolved) {
							if (itemValue.failed) {
								d.reject(itemValue.value);
								return false;
							}
							result[index] = itemValue.value;
							return true;
						}
						++waiting;
						itemValue.done(function (resolvedValue) {
							result[index] = resolvedValue;
							if (!--waiting && initialized) d.resolve(result);
						}, d.reject);
						return true;
					});
					initialized = true;
					if (!waiting) d.resolve(result);
					return d.promise;
				}
				value = assimilate(value);
				if (isPromise(value)) return value;
				return resolve(value, isError(value));
			};
			
			createDeferred.Deferred = Deferred;
			createDeferred.reject = function (value) {
				return resolve(value, true);
			};
			createDeferred.resolve = function (value) {
				value = assimilate(value);
				if (isPromise(value)) return value;
				return resolve(value, false);
			};
			ext = require("./_ext");
			assimilate = require("./assimilate");
		},
		"dynamic-queue.js": function (exports, module, require) {
			// Dynamic queue handler
			// Allows to create a promise queue, where new promises can be added to queue until last promise in
			// a queue resolves. Queue promise resolves with `undefined` value, when last promises resolves.
			
			"use strict";
			
			var aFrom          = require("es5-ext/array/from")
			  , ensureIterable = require("es5-ext/iterable/validate-object")
			  , assign         = require("es5-ext/object/assign")
			  , deferred       = require("./deferred")
			  , isPromise      = require("./is-promise")
			  , assimilate     = require("./assimilate");
			
			var DynamicQueue;
			
			module.exports = DynamicQueue = function (list) {
				if (!(this instanceof DynamicQueue)) return new DynamicQueue(list);
				list = aFrom(ensureIterable(list));
			
				assign(this, deferred());
				list.every(this.add, this);
				if (!this.waiting) {
					this.resolve();
					return null;
				}
				this.initialized = true;
				return null;
			};
			
			DynamicQueue.prototype = {
				waiting: 0,
				initialized: false,
				add: function (value) {
					if (this.promise.resolved) throw new Error("Queue was already resolved");
					++this.waiting;
					value = assimilate(value);
					if (isPromise(value)) {
						if (!value.resolved) {
							value.done(this._processValue.bind(this), this.reject);
							return true;
						}
						if (value.failed) {
							this.reject(value.value);
							return false;
						}
					}
					return this._processValue();
				},
				_processValue: function () {
					if (this.promise.resolved) return null;
					if (!--this.waiting && this.initialized) this.resolve();
					return true;
				}
			};
		},
		"ext": {
			"_process-arguments.js": function (exports, module, require) {
				"use strict";
				
				var arrayOf    = require("es5-ext/array/of")
				  , isValue    = require("es5-ext/object/is-value")
				  , deferred   = require("../deferred")
				  , isPromise  = require("../is-promise")
				  , assimilate = require("../assimilate");
				
				var push = Array.prototype.push, slice = Array.prototype.slice;
				
				module.exports = function (args, length) {
					var i, arg;
					if (isValue(length) && args.length !== length) {
						args = slice.call(args, 0, length);
						if (args.length < length) {
							push.apply(args, new Array(length - args.length));
						}
					} else {
						length = args.length;
					}
					for (i = 0; i < length; ++i) {
						arg = assimilate(args[i]);
						if (isPromise(arg)) {
							if (!arg.resolved) {
								if (length > 1) return deferred.apply(null, args);
								return arg(arrayOf);
							}
							if (arg.failed) return arg;
							args[i] = arg.value;
						}
					}
					return args;
				};
			},
			"array": {
				"every.js": function (exports, module, require) {
					// Promise aware Array's every
					
					"use strict";
					
					module.exports = require("../../lib/some-every")(false);
				},
				"find.js": function (exports, module, require) {
					// Promise aware Array's find
					// Additionally differs from some that it returns *first in order* item that matches constraint
					
					"use strict";
					
					var assign          = require("es5-ext/object/assign")
					  , isValue         = require("es5-ext/object/is-value")
					  , ensureValue     = require("es5-ext/object/valid-value")
					  , callable        = require("es5-ext/object/valid-callable")
					  , toNaturalNumber = require("es5-ext/number/to-pos-integer")
					  , deferred        = require("../../deferred")
					  , isPromise       = require("../../is-promise")
					  , assimilate      = require("../../assimilate");
					
					var call = Function.prototype.call, resolve = deferred.resolve, Find;
					
					Find = function (list, cb, context) {
						this.list = list;
						this.cb = cb;
						this.context = context;
						this.length = toNaturalNumber(list.length);
					
						while (this.current < this.length) {
							if (this.current in list) {
								assign(this, deferred());
								this.processCb = this.processCb.bind(this);
								this.process();
								return this.promise;
							}
							++this.current;
						}
						return resolve(undefined);
					};
					
					Find.prototype = {
						current: 0,
						process: function () {
							var value = assimilate(this.list[this.current]);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(this.processCb, this.reject);
									return;
								}
								if (value.failed) {
									this.reject(value.value);
									return;
								}
								value = value.value;
							}
							this.processCb(value);
						},
						processCb: function (listValue) {
							var value;
							if (this.cb) {
								try {
									value = call.call(this.cb, this.context, listValue, this.current, this.list);
								} catch (e) {
									this.reject(e);
									return;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(this.processValue.bind(this, listValue), this.reject);
										return;
									}
									if (value.failed) {
										this.reject(value.value);
										return;
									}
									value = value.value;
								}
							} else {
								value = listValue;
							}
							this.processValue(listValue, value);
						},
						processValue: function (listValue, value) {
							if (value) {
								this.resolve(listValue);
								return;
							}
							while (++this.current < this.length) {
								if (this.current in this.list) {
									this.process();
									return;
								}
							}
							this.resolve(undefined);
						}
					};
					
					module.exports = function (cb/*, thisArg*/) {
						ensureValue(this);
						if (isValue(cb)) callable(cb);
					
						return new Find(this, cb, arguments[1]);
					};
				},
				"map.js": function (exports, module, require) {
					// Promise aware Array's map
					
					"use strict";
					
					var assign          = require("es5-ext/object/assign")
					  , isValue         = require("es5-ext/object/is-value")
					  , ensureValue     = require("es5-ext/object/valid-value")
					  , callable        = require("es5-ext/object/valid-callable")
					  , toNaturalNumber = require("es5-ext/number/to-pos-integer")
					  , deferred        = require("../../deferred")
					  , isPromise       = require("../../is-promise")
					  , assimilate      = require("../../assimilate");
					
					var every = Array.prototype.every, call = Function.prototype.call, DMap;
					
					DMap = function (list, cb, context) {
						this.list = list;
						this.cb = cb;
						this.context = context;
						this.result = new Array(toNaturalNumber(list.length));
					
						assign(this, deferred());
						every.call(list, this.process, this);
						if (!this.waiting) return this.resolve(this.result);
						this.initialized = true;
					
						return this.promise;
					};
					
					DMap.prototype = {
						waiting: 0,
						initialized: false,
						process: function (value, index) {
							++this.waiting;
							value = assimilate(value);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(this.processCb.bind(this, index), this.reject);
									return true;
								}
								if (value.failed) {
									this.reject(value.value);
									return false;
								}
								value = value.value;
							}
							return this.processCb(index, value);
						},
						processCb: function (index, value) {
							if (this.promise.resolved) return false;
							if (this.cb) {
								try {
									value = call.call(this.cb, this.context, value, index, this.list);
								} catch (e) {
									this.reject(e);
									return false;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(this.processValue.bind(this, index), this.reject);
										return true;
									}
									if (value.failed) {
										this.reject(value.value);
										return false;
									}
									value = value.value;
								}
							}
							this.processValue(index, value);
							return true;
						},
						processValue: function (index, value) {
							if (this.promise.resolved) return;
							this.result[index] = value;
							if (!--this.waiting && this.initialized) this.resolve(this.result);
						}
					};
					
					module.exports = function (cb/*, thisArg*/) {
						ensureValue(this);
						if (isValue(cb)) callable(cb);
					
						return new DMap(this, cb, arguments[1]);
					};
				},
				"reduce.js": function (exports, module, require) {
					// Promise aware Array's reduce
					
					"use strict";
					
					var assign          = require("es5-ext/object/assign")
					  , isValue         = require("es5-ext/object/is-value")
					  , ensureValue     = require("es5-ext/object/valid-value")
					  , callable        = require("es5-ext/object/valid-callable")
					  , toNaturalNumber = require("es5-ext/number/to-pos-integer")
					  , deferred        = require("../../deferred")
					  , isPromise       = require("../../is-promise")
					  , assimilate      = require("../../assimilate");
					
					var call = Function.prototype.call, resolve = deferred.resolve, Reduce;
					
					Reduce = function (list, cb, initial, initialized) {
						this.list = list;
						this.cb = cb;
						this.initialized = initialized;
						this.length = toNaturalNumber(list.length);
					
						initial = assimilate(initial);
						if (isPromise(initial)) {
							if (!initial.resolved) {
								assign(this, deferred());
								initial.done(
									function (resolvedInitial) {
										this.value = resolvedInitial;
										this.init();
									}.bind(this),
									this.reject
								);
								return this.promise;
							}
							this.value = initial.value;
							if (initial.failed) return initial;
						} else {
							this.value = initial;
						}
					
						return this.init();
					};
					
					Reduce.prototype = {
						current: 0,
						state: false,
						init: function () {
							while (this.current < this.length) {
								if (hasOwnProperty.call(this.list, this.current)) break;
								++this.current;
							}
							if (this.current === this.length) {
								if (!this.initialized) {
									throw new Error("Reduce of empty array with no initial value");
								}
								return this.resolve ? this.resolve(this.value) : resolve(this.value);
							}
							if (!this.promise) assign(this, deferred());
							this.processCb = this.processCb.bind(this);
							this.processValue = this.processValue.bind(this);
							this.continue();
							return this.promise;
						},
						continue: function () {
							var result;
							while (!this.state) {
								result = this.process();
								if (this.state !== "cb") break;
								result = this.processCb(result);
								if (this.state !== "value") break;
								this.processValue(result);
							}
						},
						process: function () {
							var value = assimilate(this.list[this.current]);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(
										function (result) {
											result = this.processCb(result);
											if (this.state !== "value") return;
											this.processValue(result);
											if (!this.state) this.continue();
										}.bind(this),
										this.reject
									);
									return null;
								}
								if (value.failed) {
									this.reject(value.value);
									return null;
								}
								value = value.value;
							}
							this.state = "cb";
							return value;
						},
						processCb: function (value) {
							if (!this.initialized) {
								this.initialized = true;
								this.state = "value";
								return value;
							}
							if (this.cb) {
								try {
									value = call.call(this.cb, undefined, this.value, value, this.current, this.list);
								} catch (e) {
									this.reject(e);
									return null;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(
											function (result) {
												this.state = "value";
												this.processValue(result);
												if (!this.state) this.continue();
											}.bind(this),
											this.reject
										);
										return null;
									}
									if (value.failed) {
										this.reject(value.value);
										return null;
									}
									value = value.value;
								}
							}
							this.state = "value";
							return value;
						},
						processValue: function (value) {
							this.value = value;
							while (++this.current < this.length) {
								if (hasOwnProperty.call(this.list, this.current)) {
									this.state = false;
									return;
								}
							}
							this.resolve(this.value);
						}
					};
					
					module.exports = function (cb/*, initial*/) {
						ensureValue(this);
						if (isValue(cb)) callable(cb);
					
						return new Reduce(this, cb, arguments[1], arguments.length > 1);
					};
				},
				"some.js": function (exports, module, require) {
					// Promise aware Array's some
					
					"use strict";
					
					module.exports = require("../../lib/some-every")(true);
				}
			},
			"function": {
				"call-async.js": function (exports, module, require) {
					// Call asynchronous function
					
					"use strict";
					
					var toArray          = require("es5-ext/array/to-array")
					  , isValue          = require("es5-ext/object/is-value")
					  , callable         = require("es5-ext/object/valid-callable")
					  , deferred         = require("../../deferred")
					  , isPromise        = require("../../is-promise")
					  , processArguments = require("../_process-arguments");
					
					var slice = Array.prototype.slice, apply = Function.prototype.apply, applyFn, callAsync;
					
					applyFn = function (fn, args, def) {
						args = toArray(args);
						apply.call(
							fn,
							this,
							args.concat(function (error, result) {
								if (isValue(error)) def.reject(error);
								else def.resolve(arguments.length > 2 ? slice.call(arguments, 1) : result);
							})
						);
					};
					
					callAsync = function (fn, length, context, args) {
						var def;
						args = processArguments(args, length);
						if (isPromise(args)) {
							if (args.failed) return args;
							def = deferred();
							args.done(function (resolvedArgs) {
								if (fn.returnsPromise) {
									apply.call(fn, context, resolvedArgs);
									return;
								}
								try {
									applyFn.call(context, fn, resolvedArgs, def);
								} catch (e) {
									def.reject(e);
								}
							}, def.reject);
							return def.promise;
						}
						if (fn.returnsPromise) return apply.call(fn, context, args);
						def = deferred();
						try {
							applyFn.call(context, fn, args, def);
						} catch (e) {
							def.reject(e);
							throw e;
						}
						return def.promise;
					};
					
					module.exports = exports = function (context/*, …args*/) {
						return callAsync(callable(this), null, context, slice.call(arguments, 1));
					};
					
					Object.defineProperty(exports, "_base", {
						configurable: true,
						enumerable: false,
						writable: true,
						value: callAsync
					});
				},
				"delay.js": function (exports, module, require) {
					// Delay function execution, return promise for delayed function result
					
					"use strict";
					
					var isValue       = require("es5-ext/object/is-value")
					  , callable      = require("es5-ext/object/valid-callable")
					  , nextTick      = require("next-tick")
					  , ensureTimeout = require("timers-ext/valid-timeout")
					  , deferred      = require("../../deferred");
					
					var apply = Function.prototype.apply, delayed;
					
					delayed = function (fn, args, resolve, reject) {
						var value;
						try {
							value = apply.call(fn, this, args);
						} catch (e) {
							reject(e);
							return;
						}
						resolve(value);
					};
					
					module.exports = function (timeout) {
						var fn, result, delay;
						fn = callable(this);
						if (isValue(timeout)) {
							timeout = ensureTimeout(timeout);
							delay = setTimeout;
						} else {
							delay = nextTick;
						}
						result = function () {
							var def = deferred();
							delay(delayed.bind(this, fn, arguments, def.resolve, def.reject), timeout);
							return def.promise;
						};
						result.returnsPromise = true;
						return result;
					};
				},
				"gate.js": function (exports, module, require) {
					/* eslint max-statements: "off" */
					
					// Limit number of concurrent function executions (to cLimit number).
					// Limited calls are queued. Optionaly maximum queue length can also be
					// controlled with qLimit value, any calls that would reach over that limit
					// would be discarded (its promise would resolve with "Too many calls" error)
					
					"use strict";
					
					var toPosInt   = require("es5-ext/number/to-pos-integer")
					  , callable   = require("es5-ext/object/valid-callable")
					  , isValue    = require("es5-ext/object/is-value")
					  , eeUnify    = require("event-emitter/unify")
					  , deferred   = require("../../deferred")
					  , isPromise  = require("../../is-promise")
					  , assimilate = require("../../assimilate");
					
					var resolve = deferred.resolve
					  , reject = deferred.reject
					  , apply = Function.prototype.apply
					  , max = Math.max
					  , gateReject;
					
					require("../promise/finally");
					
					gateReject = function () {
						var e = new Error("Too many calls at the gate");
						e.code = "DEFERRED_REJECTED_AT_GATE";
						e.type = "deferred-gate-rejected";
						return reject(e);
					};
					
					module.exports = function (cLimit, qLimit) {
						var fn, count, decrement, unload, queue, run, result;
						fn = callable(this);
						cLimit = max(toPosInt(cLimit), 1);
						qLimit = !isValue(qLimit) || isNaN(qLimit) ? Infinity : toPosInt(qLimit);
						count = 0;
						queue = [];
					
						run = function (thisArg, args, def) {
							var localResult;
							try {
								localResult = apply.call(fn, thisArg, args);
							} catch (e) {
								if (!def) return reject(e);
								def.reject(e);
								return unload();
							}
							localResult = assimilate(localResult);
							if (isPromise(localResult)) {
								if (def) eeUnify(def.promise, localResult);
								if (!localResult.resolved) {
									++count;
									if (def) def.resolve(localResult);
									return localResult.finally(decrement);
								}
								if (!localResult.failed) localResult = localResult.value;
							}
							if (!def) return resolve(localResult);
							def.resolve(localResult);
							return unload();
						};
					
						decrement = function () {
							--count;
							unload();
						};
					
						unload = function () {
							var data;
							if ((data = queue.shift())) run.apply(null, data);
						};
					
						result = function () {
							var def;
							if (count >= cLimit) {
								if (queue.length < qLimit) {
									def = deferred();
									queue.push([this, arguments, def]);
									return def.promise;
								}
								return gateReject();
							}
							return run(this, arguments);
						};
						result.returnsPromise = true;
						return result;
					};
				},
				"promisify-sync.js": function (exports, module, require) {
					// Promisify synchronous function
					
					"use strict";
					
					var isValue          = require("es5-ext/object/is-value")
					  , callable         = require("es5-ext/object/valid-callable")
					  , toNaturalNumber  = require("es5-ext/number/to-pos-integer")
					  , deferred         = require("../../deferred")
					  , isPromise        = require("../../is-promise")
					  , processArguments = require("../_process-arguments");
					
					var apply = Function.prototype.apply, applyFn;
					
					applyFn = function (fn, args, resolve, reject) {
						var value;
						try {
							value = apply.call(fn, this, args);
						} catch (e) {
							reject(e);
							return;
						}
						resolve(value);
					};
					
					module.exports = function (length) {
						var fn, result;
						fn = callable(this);
						if (fn.returnsPromise) return fn;
						if (isValue(length)) length = toNaturalNumber(length);
						result = function () {
							var args, def;
							args = processArguments(arguments, length);
					
							if (isPromise(args)) {
								if (args.failed) return args;
								def = deferred();
								args.done(
									function (resolvedArgs) {
										applyFn.call(this, fn, resolvedArgs, def.resolve, def.reject);
									}.bind(this),
									def.reject
								);
							} else {
								def = deferred();
								applyFn.call(this, fn, args, def.resolve, def.reject);
							}
					
							return def.promise;
						};
						result.returnsPromise = true;
						return result;
					};
				},
				"promisify.js": function (exports, module, require) {
					// Promisify asynchronous function
					
					"use strict";
					
					var isValue         = require("es5-ext/object/is-value")
					  , callable        = require("es5-ext/object/valid-callable")
					  , toNaturalNumber = require("es5-ext/number/to-pos-integer")
					  , callAsync       = require("./call-async")._base;
					
					module.exports = function (length) {
						var fn, result;
						fn = callable(this);
						if (fn.returnsPromise) return fn;
						if (isValue(length)) length = toNaturalNumber(length);
						result = function () {
							return callAsync(fn, length, this, arguments);
						};
						result.returnsPromise = true;
						return result;
					};
				}
			},
			"promise": {
				"_array.js": function (exports, module, require) {
					// Used by promise extensions that are based on array extensions.
					
					"use strict";
					
					var isValue  = require("es5-ext/object/is-value")
					  , callable = require("es5-ext/object/valid-callable")
					  , deferred = require("../../deferred");
					
					var reject = deferred.reject;
					
					module.exports = function (name, ext) {
						deferred.extend(
							name,
							function (cb) {
								var def;
								if (isValue(cb)) callable(cb);
								if (!this.pending) this.pending = [];
								def = deferred();
								this.pending.push(name, [arguments, def.resolve, def.reject]);
								return def.promise;
							},
							function (args, resolve) {
								var result;
								if (this.failed) {
									reject(this.value);
									return;
								}
								try {
									result = ext.apply(this.value, args);
								} catch (e) {
									reject(e);
									return;
								}
								resolve(result);
							},
							function (cb) {
								if (isValue(cb)) callable(cb);
								if (this.failed) return this;
								try {
									return ext.apply(this.value, arguments);
								} catch (e) {
									return reject(e);
								}
							}
						);
					};
				},
				"aside.js": function (exports, module, require) {
					// 'aside' - Promise extension
					//
					// promise.aside(win, fail)
					//
					// Works in analogous way as promise function itself (or `then`)
					// but instead of adding promise to promise chain it returns context promise and
					// lets callback carry on with other processing logic
					
					"use strict";
					
					var isValue  = require("es5-ext/object/is-value")
					  , callable = require("es5-ext/object/valid-callable")
					  , deferred = require("../../deferred");
					
					deferred.extend(
						"aside",
						function (win, fail) {
							if (isValue(win)) callable(win);
							if (isValue(fail)) callable(fail);
							if (win || fail) {
								if (!this.pending) {
									this.pending = [];
								}
								this.pending.push("aside", arguments);
							}
							return this;
						},
						function (win, fail) {
							var cb = this.failed ? fail : win;
							if (cb) {
								cb(this.value);
							}
						},
						function (win, fail) {
							var cb;
							if (isValue(win)) callable(win);
							if (isValue(fail)) callable(fail);
							cb = this.failed ? fail : win;
							if (cb) {
								cb(this.value);
							}
							return this;
						}
					);
				},
				"catch.js": function (exports, module, require) {
					// 'catch' - Promise extension
					//
					// promise.catch(cb)
					//
					// Same as `then` but accepts only onFail callback
					
					"use strict";
					
					var isCallable = require("es5-ext/object/is-callable")
					  , validValue = require("es5-ext/object/valid-value")
					  , deferred   = require("../../deferred")
					  , isPromise  = require("../../is-promise")
					  , resolve    = deferred.resolve
					  , reject     = deferred.reject;
					
					deferred.extend(
						"catch",
						function (cb) {
							var def;
							validValue(cb);
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push("catch", [cb, def.resolve, def.reject]);
							return def.promise;
						},
						function (cb, localResolve, localReject) {
							var value;
							if (!this.failed) {
								localResolve(this.value);
								return;
							}
							if (isCallable(cb)) {
								if (isPromise(cb)) {
									if (cb.resolved) {
										if (cb.failed) localReject(cb.value);
										else localResolve(cb.value);
									} else {
										cb.done(localResolve, localReject);
									}
									return;
								}
								try {
									value = cb(this.value);
								} catch (e) {
									localReject(e);
									return;
								}
								localResolve(value);
								return;
							}
							localResolve(cb);
						},
						function (cb) {
							var value;
							validValue(cb);
							if (!this.failed) return this;
							if (isCallable(cb)) {
								if (isPromise(cb)) return cb;
								try {
									value = cb(this.value);
								} catch (e) {
									return reject(e);
								}
								return resolve(value);
							}
							return resolve(cb);
						}
					);
				},
				"cb.js": function (exports, module, require) {
					// 'cb' - Promise extension
					//
					// promise.cb(cb)
					//
					// Handles asynchronous function style callback (which is run in next event loop
					// the earliest). Returns self promise. Callback is optional.
					//
					// Useful when we want to configure typical asynchronous function which logic is
					// internally configured with promises.
					//
					// Extension can be used as follows:
					//
					// var foo = function (arg1, arg2, cb) {
					//     var d = deferred();
					//     // ... implementation
					//     return d.promise.cb(cb);
					// };
					//
					// `cb` extension returns promise and handles eventual callback (optional)
					
					"use strict";
					
					var isValue  = require("es5-ext/object/is-value")
					  , callable = require("es5-ext/object/valid-callable")
					  , nextTick = require("next-tick")
					  , deferred = require("../../deferred");
					
					deferred.extend(
						"cb",
						function (cb) {
							if (!isValue(cb)) return this;
							callable(cb);
							nextTick(
								function () {
									if (this.resolved) {
										if (this.failed) cb(this.value);
										else cb(null, this.value);
									} else {
										if (!this.pending) this.pending = [];
										this.pending.push("cb", [cb]);
									}
								}.bind(this)
							);
							return this;
						},
						function (cb) {
							if (this.failed) cb(this.value);
							else cb(null, this.value);
						},
						function (cb) {
							if (!isValue(cb)) return this;
							callable(cb);
							nextTick(
								function () {
									if (this.failed) cb(this.value);
									else cb(null, this.value);
								}.bind(this)
							);
							return this;
						}
					);
				},
				"finally.js": function (exports, module, require) {
					// 'finally' - Promise extension
					//
					// promise.finally(cb)
					//
					// Called on promise resolution returns same promise, doesn't pass any values to
					// provided callback
					
					"use strict";
					
					var callable = require("es5-ext/object/valid-callable")
					  , deferred = require("../../deferred");
					
					deferred.extend("finally", function (cb) {
						callable(cb);
						if (!this.pending) this.pending = [];
						this.pending.push("finally", arguments);
						return this;
					}, function (cb) {
					 cb();
					}, function (cb) {
						callable(cb)();
						return this;
					});
				},
				"get.js": function (exports, module, require) {
					// 'get' - Promise extension
					//
					// promise.get(name)
					//
					// Resolves with property of resolved object
					
					"use strict";
					
					var value    = require("es5-ext/object/valid-value")
					  , deferred = require("../../deferred");
					
					var reduce = Array.prototype.reduce, resolve = deferred.resolve, reject = deferred.reject;
					
					deferred.extend(
						"get",
						function (/* …name*/) {
							var def;
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push("get", [arguments, def.resolve, def.reject]);
							return def.promise;
						},
						function (args, localResolve, localReject) {
							var result;
							if (this.failed) localReject(this.value);
							try {
								result = reduce.call(
									args,
									function (obj, key) {
										return value(obj)[String(key)];
									},
									this.value
								);
							} catch (e) {
								localReject(e);
								return;
							}
							localResolve(result);
						},
						function (/* …name*/) {
							var result;
							if (this.failed) return this;
							try {
								result = reduce.call(
									arguments,
									function (obj, key) {
										return value(obj)[String(key)];
									},
									this.value
								);
							} catch (e) {
								return reject(e);
							}
							return resolve(result);
						}
					);
				},
				"invoke-async.js": function (exports, module, require) {
					/* eslint max-statements: "off" */
					
					// 'invokeAsync' - Promise extension
					//
					// promise.invokeAsync(name[, arg0[, arg1[, ...]]])
					//
					// On resolved object calls asynchronous method that takes callback
					// (Node.js style).
					// Do not pass callback, it's handled by internal implementation.
					// 'name' can be method name or method itself.
					
					"use strict";
					
					var toArray          = require("es5-ext/array/to-array")
					  , isValue          = require("es5-ext/object/is-value")
					  , isCallable       = require("es5-ext/object/is-callable")
					  , deferred         = require("../../deferred")
					  , isPromise        = require("../../is-promise")
					  , processArguments = require("../_process-arguments");
					
					var slice = Array.prototype.slice
					  , apply = Function.prototype.apply
					  , reject = deferred.reject
					  , applyFn;
					
					applyFn = function (fn, args, localResolve, localReject) {
						var result;
						if (fn.returnsPromise) {
							try {
								result = apply.call(fn, this, args);
							} catch (e) {
								localReject(e);
								return;
							}
							localResolve(result);
							return;
						}
						args = toArray(args).concat(function (error, localResult) {
							if (isValue(error)) {
								localReject(error);
							} else {
								localResolve(arguments.length > 2 ? slice.call(arguments, 1) : localResult);
							}
						});
						try {
							apply.call(fn, this, args);
						} catch (e2) {
							localReject(e2);
						}
					};
					
					deferred.extend(
						"invokeAsync",
						function (methodIgnored/*, …args*/) {
							var def;
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push("invokeAsync", [arguments, def.resolve, def.reject]);
							return def.promise;
						},
						function (args, localResolve, localReject) {
							var fn;
							if (this.failed) {
								localReject(this.value);
								return;
							}
					
							if (!isValue(this.value)) {
								localReject(new TypeError("Cannot use null or undefined"));
								return;
							}
					
							fn = args[0];
							if (!isCallable(fn)) {
								fn = String(fn);
								if (!isCallable(this.value[fn])) {
									localReject(new TypeError(fn + " is not a function"));
									return;
								}
								fn = this.value[fn];
							}
					
							args = processArguments(slice.call(args, 1));
							if (isPromise(args)) {
								if (args.failed) {
									localReject(args.value);
									return;
								}
								args.done(
									function (argsResolved) {
										applyFn.call(this, fn, argsResolved, localResolve, localReject);
									}.bind(this.value),
									localReject
								);
							} else {
								applyFn.call(this.value, fn, args, localResolve, localReject);
							}
						},
						function (method/*, …args*/) {
							var args, def;
							if (this.failed) return this;
					
							if (!isValue(this.value)) {
								return reject(new TypeError("Cannot use null or undefined"));
							}
					
							if (!isCallable(method)) {
								method = String(method);
								if (!isCallable(this.value[method])) {
									return reject(new TypeError(method + " is not a function"));
								}
								method = this.value[method];
							}
					
							args = processArguments(slice.call(arguments, 1));
							if (isPromise(args)) {
								if (args.failed) return args;
								def = deferred();
								args.done(
									function (argsResolved) {
										applyFn.call(this, method, argsResolved, def.resolve, def.reject);
									}.bind(this.value),
									def.reject
								);
							} else if (method.returnsPromise) {
								return applyFn.call(this.value, method, args, deferred, reject);
							} else {
								def = deferred();
								applyFn.call(this.value, method, args, def.resolve, def.reject);
							}
							return def.promise;
						}
					);
				},
				"invoke.js": function (exports, module, require) {
					/* eslint max-statements: "off" */
					
					// 'invoke' - Promise extension
					//
					// promise.invoke(name[, arg0[, arg1[, ...]]])
					//
					// On resolved object calls method that returns immediately.
					// 'name' can be method name or method itself.
					
					"use strict";
					
					var isValue          = require("es5-ext/object/is-value")
					  , isCallable       = require("es5-ext/object/is-callable")
					  , deferred         = require("../../deferred")
					  , isPromise        = require("../../is-promise")
					  , processArguments = require("../_process-arguments");
					
					var slice = Array.prototype.slice
					  , apply = Function.prototype.apply
					  , reject = deferred.reject
					  , applyFn;
					
					applyFn = function (fn, args, localResolve, localReject) {
						var value;
						try {
							value = apply.call(fn, this, args);
						} catch (e) {
							return localReject(e);
						}
						return localResolve(value);
					};
					
					deferred.extend(
						"invoke",
						function (methodIgnored/*, …args*/) {
							var def;
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push("invoke", [arguments, def.resolve, def.reject]);
							return def.promise;
						},
						function (args, localResolve, localReject) {
							var fn;
							if (this.failed) {
								localReject(this.value);
								return;
							}
					
							if (!isValue(this.value)) {
								localReject(new TypeError("Cannot use null or undefined"));
								return;
							}
					
							fn = args[0];
							if (!isCallable(fn)) {
								fn = String(fn);
								if (!isCallable(this.value[fn])) {
									localReject(new TypeError(fn + " is not a function"));
									return;
								}
								fn = this.value[fn];
							}
					
							args = processArguments(slice.call(args, 1));
							if (isPromise(args)) {
								if (args.failed) {
									localReject(args.value);
									return;
								}
								args.done(
									function (argsResolved) {
										applyFn.call(this, fn, argsResolved, localResolve, localReject);
									}.bind(this.value),
									localReject
								);
							} else {
								applyFn.call(this.value, fn, args, localResolve, localReject);
							}
						},
						function (method/*, …args*/) {
							var args, def;
							if (this.failed) return this;
					
							if (!isValue(this.value)) {
								return reject(new TypeError("Cannot use null or undefined"));
							}
					
							if (!isCallable(method)) {
								method = String(method);
								if (!isCallable(this.value[method])) {
									return reject(new TypeError(method + " is not a function"));
								}
								method = this.value[method];
							}
					
							args = processArguments(slice.call(arguments, 1));
							if (isPromise(args)) {
								if (args.failed) return args;
								def = deferred();
								args.done(
									function (argsResolved) {
										applyFn.call(this, method, argsResolved, def.resolve, def.reject);
									}.bind(this.value),
									def.reject
								);
								return def.promise;
							}
							return applyFn.call(this.value, method, args, deferred, reject);
						}
					);
				},
				"map.js": function (exports, module, require) {
					// 'map' - Promise extension
					//
					// promise.map(fn[, thisArg[, concurrentLimit]])
					//
					// Promise aware map for array-like results
					
					"use strict";
					
					require("./_array")("map", require("../array/map"));
				},
				"reduce.js": function (exports, module, require) {
					// 'reduce' - Promise extension
					//
					// promise.reduce(fn[, initial])
					//
					// Promise aware reduce for array-like results
					
					"use strict";
					
					require("./_array")("reduce", require("../array/reduce"));
				},
				"some.js": function (exports, module, require) {
					// 'some' - Promise extension
					//
					// promise.some(fn[, thisArg])
					//
					// Promise aware some for array-like results
					
					"use strict";
					
					require("./_array")("some", require("../array/some"));
				},
				"spread.js": function (exports, module, require) {
					// 'spread' - Promise extensions
					//
					// promise.spread(onsuccess, onerror)
					//
					// Matches eventual list result onto function arguments,
					// otherwise works same as 'then' (promise function itself)
					
					"use strict";
					
					var spread     = require("es5-ext/function/#/spread")
					  , isValue    = require("es5-ext/object/is-value")
					  , callable   = require("es5-ext/object/valid-callable")
					  , isCallable = require("es5-ext/object/is-callable")
					  , isPromise  = require("../../is-promise")
					  , deferred   = require("../../deferred");
					
					var resolve = deferred.resolve, reject = deferred.reject;
					
					deferred.extend(
						"spread",
						function (win, fail) {
							var def;
							if (isValue(win)) callable(win);
							if (!win && !isValue(fail)) return this;
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push("spread", [win, fail, def.resolve, def.reject]);
							return def.promise;
						},
						function (win, fail, localResolve, localReject) {
							var cb, value;
							cb = this.failed ? fail : win;
							if (!isValue(cb)) {
								if (this.failed) localReject(this.value);
								else localResolve(this.value);
							}
							if (isCallable(cb)) {
								if (isPromise(cb)) {
									if (cb.resolved) {
										if (cb.failed) localReject(cb.value);
										else localResolve(cb.value);
									} else {
										cb.done(localResolve, localReject);
									}
									return;
								}
								if (!this.failed) cb = spread.call(cb);
								try {
									value = cb(this.value);
								} catch (e) {
									localReject(e);
									return;
								}
								localResolve(value);
							} else {
								localResolve(cb);
							}
						},
						function (win, fail) {
							var cb, value;
							cb = this.failed ? fail : win;
							if (!isValue(cb)) return this;
							if (isCallable(cb)) {
								if (isPromise(cb)) return cb;
								if (!this.failed) cb = spread.call(cb);
								try {
									value = cb(this.value);
								} catch (e) {
									return reject(e);
								}
								return resolve(value);
							}
							return resolve(cb);
						}
					);
				},
				"timeout.js": function (exports, module, require) {
					// 'timeout' - Promise extension
					//
					// promise.timeout(ms)
					//
					// Resolves with resolution value of context promise assuming it settles before timeout time passes
					// Otherwise resolves with timeout rejection
					
					"use strict";
					
					var customError   = require("es5-ext/error/custom")
					  , isValue       = require("es5-ext/object/is-value")
					  , nextTick      = require("next-tick")
					  , ensureTimeout = require("timers-ext/valid-timeout")
					  , deferred      = require("../../deferred");
					
					deferred.extend(
						"timeout",
						function (timeout) {
							var def;
							var callback = function () {
								if (this.resolved) return;
								def.reject(customError("Operation timeout", "DEFERRED_TIMEOUT"));
							}.bind(this);
							if (isValue(timeout)) setTimeout(callback, ensureTimeout(timeout));
							else nextTick(callback);
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push("timeout", [def.promise, def.resolve]);
							return def.promise;
						},
						function (promise, resolve) {
							if (!promise.resolved) resolve(this);
						},
						function (timeout) {
							if (isValue(timeout)) ensureTimeout(timeout);
							return this;
						}
					);
				}
			}
		},
		"index.js": function (exports, module, require) {
			// This construct deferred with all needed goodies that are being exported
			// when we import 'deferred' by main name.
			// All available promise extensions are also initialized.
			
			"use strict";
			
			var call   = Function.prototype.call
			  , assign = require("es5-ext/object/assign");
			
			module.exports = assign(
				require("./deferred"),
				{
					invokeAsync: require("./invoke-async"),
					isPromise: require("./is-promise"),
					dynamicQueue: require("./dynamic-queue"),
					validPromise: require("./valid-promise"),
					callAsync: call.bind(require("./ext/function/call-async")),
					delay: call.bind(require("./ext/function/delay")),
					gate: call.bind(require("./ext/function/gate")),
					monitor: require("./monitor"),
					promisify: call.bind(require("./ext/function/promisify")),
					promisifySync: call.bind(require("./ext/function/promisify-sync")),
					every: call.bind(require("./ext/array/every")),
					find: call.bind(require("./ext/array/find")),
					map: call.bind(require("./ext/array/map")),
					reduce: call.bind(require("./ext/array/reduce")),
					some: call.bind(require("./ext/array/some"))
				},
				require("./profiler")
			);
			
			require("./ext/promise/aside");
			require("./ext/promise/catch");
			require("./ext/promise/cb");
			require("./ext/promise/finally");
			require("./ext/promise/get");
			require("./ext/promise/invoke");
			require("./ext/promise/invoke-async");
			require("./ext/promise/map");
			require("./ext/promise/reduce");
			require("./ext/promise/spread");
			require("./ext/promise/some");
			require("./ext/promise/timeout");
		},
		"invoke-async.js": function (exports, module, require) {
			// Invoke asynchronous function
			
			"use strict";
			
			var isCallable = require("es5-ext/object/is-callable")
			  , callable   = require("es5-ext/object/valid-callable")
			  , value      = require("es5-ext/object/valid-value")
			  , callAsync  = require("./ext/function/call-async")._base
			
			  , slice = Array.prototype.slice;
			
			module.exports = function (obj, fn/*, …args*/) {
				value(obj);
				if (!isCallable(fn)) fn = callable(obj[fn]);
				return callAsync(fn, null, obj, slice.call(arguments, 2));
			};
		},
		"is-promise.js": function (exports, module, require) {
			// Whether given object is a promise
			
			"use strict";
			
			module.exports = function (value) {
				return (
					typeof value === "function" && typeof value.then === "function" && value.end !== value.done
				);
			};
		},
		"lib": {
			"some-every.js": function (exports, module, require) {
				// Promise aware Array's some
				
				"use strict";
				
				var assign          = require("es5-ext/object/assign")
				  , isValue         = require("es5-ext/object/is-value")
				  , ensureValue     = require("es5-ext/object/valid-value")
				  , callable        = require("es5-ext/object/valid-callable")
				  , toNaturalNumber = require("es5-ext/number/to-pos-integer")
				  , deferred        = require("../deferred")
				  , isPromise       = require("../is-promise")
				  , assimilate      = require("../assimilate");
				
				var call = Function.prototype.call, resolve = deferred.resolve;
				
				module.exports = function (resolvent) {
					var Iterator = function (list, cb, context) {
						this.list = list;
						this.cb = cb;
						this.context = context;
						this.length = toNaturalNumber(list.length);
				
						while (this.current < this.length) {
							if (this.current in list) {
								assign(this, deferred());
								this.processCb = this.processCb.bind(this);
								this.processValue = this.processValue.bind(this);
								this.continue();
								return this.promise;
							}
							++this.current;
						}
						return resolve(!resolvent);
					};
				
					Iterator.prototype = {
						current: 0,
						state: false,
						continue: function () {
							var result;
							while (!this.state) {
								result = this.process();
								if (this.state !== "cb") break;
								result = this.processCb(result);
								if (this.state !== "value") break;
								this.processValue(result);
							}
						},
						process: function () {
							var value = assimilate(this.list[this.current]);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(
										function (result) {
											result = this.processCb(result);
											if (this.state !== "value") return;
											this.processValue(result);
											if (!this.state) this.continue();
										}.bind(this),
										this.reject
									);
									return null;
								}
								if (value.failed) {
									this.reject(value.value);
									return null;
								}
								value = value.value;
							}
							this.state = "cb";
							return value;
						},
						processCb: function (value) {
							if (this.cb) {
								try {
									value = call.call(this.cb, this.context, value, this.current, this.list);
								} catch (e) {
									this.reject(e);
									return null;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(
											function (result) {
												this.state = "value";
												this.processValue(result);
												if (!this.state) this.continue();
											}.bind(this),
											this.reject
										);
										return null;
									}
									if (value.failed) {
										this.reject(value.value);
										return null;
									}
									value = value.value;
								}
							}
							this.state = "value";
							return value;
						},
						processValue: function (value) {
							if (Boolean(value) === resolvent) {
								this.resolve(resolvent);
								return;
							}
							while (++this.current < this.length) {
								if (this.current in this.list) {
									this.state = false;
									return;
								}
							}
							this.resolve(!resolvent);
						}
					};
				
					return function (cb/*, thisArg*/) {
						ensureValue(this);
						if (isValue(cb)) callable(cb);
				
						return new Iterator(this, cb, arguments[1]);
					};
				};
			}
		},
		"monitor.js": function (exports, module, require) {
			/* eslint no-console: "off" */
			
			// Run if you want to monitor unresolved promises (in properly working
			// application there should be no promises that are never resolved)
			
			"use strict";
			
			var max        = Math.max
			  , isValue    = require("es5-ext/object/is-value")
			  , callable   = require("es5-ext/object/valid-callable")
			  , isCallable = require("es5-ext/object/is-callable")
			  , toPosInt   = require("es5-ext/number/to-pos-integer")
			  , deferred   = require("./deferred");
			
			exports = module.exports = function (timeout, cb) {
				if (timeout === false) {
					// Cancel monitor
					delete deferred._monitor;
					delete exports.timeout;
					delete exports.callback;
					return;
				}
				exports.timeout = timeout = max(toPosInt(timeout) || 5000, 50);
				if (isValue(cb)) {
					callable(cb);
				} else if (typeof console !== "undefined" && console && isCallable(console.error)) {
					cb = function (e) {
						console.error(
							(e.stack && e.stack.toString()) || "Unresolved promise: no stack available"
						);
					};
				}
				exports.callback = cb;
			
				deferred._monitor = function () {
					var e = new Error("Unresolved promise");
					return setTimeout(function () {
						if (cb) cb(e);
					}, timeout);
				};
			};
		},
		"profiler.js": function (exports, module, require) {
			"use strict";
			
			var partial  = require("es5-ext/function/#/partial")
			  , forEach  = require("es5-ext/object/for-each")
			  , pad      = require("es5-ext/string/#/pad")
			  , deferred = require("./deferred");
			
			var resolved, rStats, unresolved, uStats, profile;
			
			exports.profile = function () {
				resolved = 0;
				rStats = {};
				unresolved = 0;
				uStats = {};
				deferred._profile = profile;
			};
			
			profile = function (isResolved) {
				var stack, data;
			
				if (isResolved) {
					++resolved;
					data = rStats;
				} else {
					++unresolved;
					data = uStats;
				}
			
				stack = new Error().stack;
				if (
					!stack
						.split("\n")
						.slice(3)
						.some(function (line) {
							if (
								line.search(/[/\\]deferred[/\\]/) === -1 &&
								line.search(/[/\\]es5-ext[/\\]/) === -1 &&
								line.indexOf(" (native)") === -1
							) {
								line = line.replace(/\n/g, "\\n").trim();
								if (!data[line]) {
									data[line] = { count: 0 };
								}
								++data[line].count;
								return true;
							}
							return false;
						})
				) {
					if (!data.unknown) {
						data.unknown = { count: 0, stack: stack };
					}
					++data.unknown.count;
				}
			};
			
			exports.profileEnd = function () {
				var total, lpad, log = "";
			
				if (!deferred._profile) {
					throw new Error("Deferred profiler was not initialized");
				}
				delete deferred._profile;
			
				log += "------------------------------------------------------------\n";
				log += "Deferred usage statistics:\n\n";
			
				total = String(resolved + unresolved);
				lpad = partial.call(pad, " ", total.length);
				log += total + " Total promises initialized\n";
				log += lpad.call(unresolved) + " Initialized as Unresolved\n";
				log += lpad.call(resolved) + " Initialized as Resolved\n";
			
				if (unresolved) {
					log += "\nUnresolved promises were initialized at:\n";
					forEach(
						uStats,
						function (data, name) {
							log += lpad.call(data.count) + " " + name + "\n";
						},
						null,
						function (data1, data2) {
							return this[data2].count - this[data1].count;
						}
					);
				}
			
				if (resolved) {
					log += "\nResolved promises were initialized at:\n";
					forEach(
						rStats,
						function (data, name) {
							log += lpad.call(data.count) + " " + name + "\n";
						},
						null,
						function (data1, data2) {
							return this[data2].count - this[data1].count;
						}
					);
				}
				log += "------------------------------------------------------------\n";
			
				return {
					log: log,
					resolved: { count: resolved, stats: rStats },
					unresolved: { count: unresolved, stats: uStats }
				};
			};
		},
		"valid-promise.js": function (exports, module, require) {
			"use strict";
			
			var isPromise = require("./is-promise");
			
			module.exports = function (value) {
				if (!isPromise(value)) {
					throw new TypeError(value + " is not a promise object");
				}
				return value;
			};
		}
	},
	"es5-ext": {
		"array": {
			"from": {
				"index.js": function (exports, module, require) {
					"use strict";

					module.exports = require("./is-implemented")()
						? Array.from
						: require("./shim");
				},
				"is-implemented.js": function (exports, module, require) {
					"use strict";

					module.exports = function () {
						var from = Array.from, arr, result;
						if (typeof from !== "function") return false;
						arr = ["raz", "dwa"];
						result = from(arr);
						return Boolean(result && (result !== arr) && (result[1] === "dwa"));
					};
				},
				"shim.js": function (exports, module, require) {
					"use strict";

					var iteratorSymbol = require("es6-symbol").iterator
					  , isArguments    = require("../../function/is-arguments")
					  , isFunction     = require("../../function/is-function")
					  , toPosInt       = require("../../number/to-pos-integer")
					  , callable       = require("../../object/valid-callable")
					  , validValue     = require("../../object/valid-value")
					  , isValue        = require("../../object/is-value")
					  , isString       = require("../../string/is-string")
					  , isArray        = Array.isArray
					  , call           = Function.prototype.call
					  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
					  , defineProperty = Object.defineProperty;

					// eslint-disable-next-line complexity
					module.exports = function (arrayLike /*, mapFn, thisArg*/) {
						var mapFn = arguments[1]
						  , thisArg = arguments[2]
						  , Context
						  , i
						  , j
						  , arr
						  , length
						  , code
						  , iterator
						  , result
						  , getIterator
						  , value;

						arrayLike = Object(validValue(arrayLike));

						if (isValue(mapFn)) callable(mapFn);
						if (!this || this === Array || !isFunction(this)) {
							// Result: Plain array
							if (!mapFn) {
								if (isArguments(arrayLike)) {
									// Source: Arguments
									length = arrayLike.length;
									if (length !== 1) return Array.apply(null, arrayLike);
									arr = new Array(1);
									arr[0] = arrayLike[0];
									return arr;
								}
								if (isArray(arrayLike)) {
									// Source: Array
									arr = new Array(length = arrayLike.length);
									for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
									return arr;
								}
							}
							arr = [];
						} else {
							// Result: Non plain array
							Context = this;
						}

						if (!isArray(arrayLike)) {
							if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
								// Source: Iterator
								iterator = callable(getIterator).call(arrayLike);
								if (Context) arr = new Context();
								result = iterator.next();
								i = 0;
								while (!result.done) {
									value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
									if (Context) {
										desc.value = value;
										defineProperty(arr, i, desc);
									} else {
										arr[i] = value;
									}
									result = iterator.next();
									++i;
								}
								length = i;
							} else if (isString(arrayLike)) {
								// Source: String
								length = arrayLike.length;
								if (Context) arr = new Context();
								for (i = 0, j = 0; i < length; ++i) {
									value = arrayLike[i];
									if (i + 1 < length) {
										code = value.charCodeAt(0);
										// eslint-disable-next-line max-depth
										if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
									}
									value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
									if (Context) {
										desc.value = value;
										defineProperty(arr, j, desc);
									} else {
										arr[j] = value;
									}
									++j;
								}
								length = j;
							}
						}
						if (length === undefined) {
							// Source: array or array-like
							length = toPosInt(arrayLike.length);
							if (Context) arr = new Context(length);
							for (i = 0; i < length; ++i) {
								value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
								if (Context) {
									desc.value = value;
									defineProperty(arr, i, desc);
								} else {
									arr[i] = value;
								}
							}
						}
						if (Context) {
							desc.value = null;
							arr.length = length;
						}
						return arr;
					};
				}
			},
			"of": {
				"index.js": function (exports, module, require) {
					"use strict";

					module.exports = require("./is-implemented")()
						? Array.of
						: require("./shim");
				},
				"is-implemented.js": function (exports, module, require) {
					"use strict";

					module.exports = function () {
						var of = Array.of, result;
						if (typeof of !== "function") return false;
						result = of("foo", "bar");
						return Boolean(result && (result[1] === "bar"));
					};
				},
				"shim.js": function (exports, module, require) {
					"use strict";

					var isFunction     = require("../../function/is-function")
					  , slice          = Array.prototype.slice
					  , defineProperty = Object.defineProperty
					  , desc           = { configurable: true, enumerable: true, writable: true, value: null };

					module.exports = function (/* …items*/) {
						var result, i, length;
						if (!this || this === Array || !isFunction(this)) return slice.call(arguments);
						result = new this(length = arguments.length);
						for (i = 0; i < length; ++i) {
							desc.value = arguments[i];
							defineProperty(result, i, desc);
						}
						desc.value = null;
						result.length = length;
						return result;
					};
				}
			},
			"to-array.js": function (exports, module, require) {
				"use strict";

				var from = require("./from")

				  , isArray = Array.isArray;

				module.exports = function (arrayLike) {
					return isArray(arrayLike) ? arrayLike : from(arrayLike);
				};
			}
		},
		"error": {
			"custom.js": function (exports, module, require) {
				"use strict";

				var assign            = require("../object/assign")
				  , isObject          = require("../object/is-object")
				  , isValue           = require("../object/is-value")
				  , captureStackTrace = Error.captureStackTrace;

				exports = module.exports = function (message /*, code, ext*/) {
					var err = new Error(message), code = arguments[1], ext = arguments[2];
					if (!isValue(ext)) {
						if (isObject(code)) {
							ext = code;
							code = null;
						}
					}
					if (isValue(ext)) assign(err, ext);
					if (isValue(code)) err.code = code;
					if (captureStackTrace) captureStackTrace(err, exports);
					return err;
				};
			},
			"is-error.js": function (exports, module, require) {
				"use strict";

				var objToString = Object.prototype.toString, id = objToString.call(new Error());

				module.exports = function (value) {
					return (value && (value instanceof Error || objToString.call(value) === id)) || false;
				};
			}
		},
		"function": {
			"#": {
				"partial.js": function (exports, module, require) {
					"use strict";

					var callable     = require("../../object/valid-callable")
					  , aFrom        = require("../../array/from")
					  , defineLength = require("../_define-length")

					  , apply = Function.prototype.apply;

					module.exports = function (/* …args*/) {
						var fn = callable(this)
						  , args = aFrom(arguments);

						return defineLength(function () {
							return apply.call(fn, this, args.concat(aFrom(arguments)));
						}, fn.length - args.length);
					};
				},
				"spread.js": function (exports, module, require) {
					"use strict";

					var callable = require("../../object/valid-callable")

					  , apply = Function.prototype.apply;

					module.exports = function () {
						var fn = callable(this);
						return function (args) {
					 return apply.call(fn, this, args);
					};
					};
				}
			},
			"_define-length.js": function (exports, module, require) {
				"use strict";

				var toPosInt = require("../number/to-pos-integer");

				var test = function (arg1, arg2) {
					return arg2;
				};

				var desc, defineProperty, generate, mixin;

				try {
					Object.defineProperty(test, "length", {
						configurable: true,
						writable: false,
						enumerable: false,
						value: 1
					});
				} catch (ignore) {}

				if (test.length === 1) {
					// ES6
					desc = { configurable: true, writable: false, enumerable: false };
					defineProperty = Object.defineProperty;
					module.exports = function (fn, length) {
						length = toPosInt(length);
						if (fn.length === length) return fn;
						desc.value = length;
						return defineProperty(fn, "length", desc);
					};
				} else {
					mixin = require("../object/mixin");
					generate = (function () {
						var cache = [];
						return function (length) {
							var args, i = 0;
							if (cache[length]) return cache[length];
							args = [];
							while (length--) args.push("a" + (++i).toString(36));
							// eslint-disable-next-line no-new-func
							return new Function(
								"fn",
								"return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
							);
						};
					}());
					module.exports = function (src, length) {
						var target;
						length = toPosInt(length);
						if (src.length === length) return src;
						target = generate(length)(src);
						try {
							mixin(target, src);
						} catch (ignore) {}
						return target;
					};
				}
			},
			"is-arguments.js": function (exports, module, require) {
				"use strict";

				var objToString = Object.prototype.toString
				  , id = objToString.call(
					(function () {
						return arguments;
					})()
				);

				module.exports = function (value) {
					return objToString.call(value) === id;
				};
			},
			"is-function.js": function (exports, module, require) {
				"use strict";

				var objToString = Object.prototype.toString, id = objToString.call(require("./noop"));

				module.exports = function (value) {
					return typeof value === "function" && objToString.call(value) === id;
				};
			},
			"noop.js": function (exports, module, require) {
				"use strict";

				// eslint-disable-next-line no-empty-function
				module.exports = function () {};
			}
		},
		"iterable": {
			"is.js": function (exports, module, require) {
				"use strict";

				var iteratorSymbol = require("es6-symbol").iterator
				  , isValue        = require("../object/is-value")
				  , isArrayLike    = require("../object/is-array-like");

				module.exports = function (value) {
					if (!isValue(value)) return false;
					if (typeof value[iteratorSymbol] === "function") return true;
					return isArrayLike(value);
				};
			},
			"validate-object.js": function (exports, module, require) {
				"use strict";

				var isObject = require("../object/is-object")
				  , is       = require("./is");

				module.exports = function (value) {
					if (is(value) && isObject(value)) return value;
					throw new TypeError(value + " is not an iterable or array-like object");
				};
			}
		},
		"math": {
			"sign": {
				"index.js": function (exports, module, require) {
					"use strict";

					module.exports = require("./is-implemented")()
						? Math.sign
						: require("./shim");
				},
				"is-implemented.js": function (exports, module, require) {
					"use strict";

					module.exports = function () {
						var sign = Math.sign;
						if (typeof sign !== "function") return false;
						return (sign(10) === 1) && (sign(-20) === -1);
					};
				},
				"shim.js": function (exports, module, require) {
					"use strict";

					module.exports = function (value) {
						value = Number(value);
						if (isNaN(value) || (value === 0)) return value;
						return value > 0 ? 1 : -1;
					};
				}
			}
		},
		"number": {
			"to-integer.js": function (exports, module, require) {
				"use strict";

				var sign = require("../math/sign")

				  , abs = Math.abs, floor = Math.floor;

				module.exports = function (value) {
					if (isNaN(value)) return 0;
					value = Number(value);
					if ((value === 0) || !isFinite(value)) return value;
					return sign(value) * floor(abs(value));
				};
			},
			"to-pos-integer.js": function (exports, module, require) {
				"use strict";

				var toInteger = require("./to-integer")

				  , max = Math.max;

				module.exports = function (value) {
				 return max(0, toInteger(value));
				};
			}
		},
		"object": {
			"_iterate.js": function (exports, module, require) {
				// Internal method, used by iteration functions.
				// Calls a function for each key-value pair found in object
				// Optionally takes compareFn to iterate object in specific order

				"use strict";

				var callable                = require("./valid-callable")
				  , value                   = require("./valid-value")
				  , bind                    = Function.prototype.bind
				  , call                    = Function.prototype.call
				  , keys                    = Object.keys
				  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

				module.exports = function (method, defVal) {
					return function (obj, cb /*, thisArg, compareFn*/) {
						var list, thisArg = arguments[2], compareFn = arguments[3];
						obj = Object(value(obj));
						callable(cb);

						list = keys(obj);
						if (compareFn) {
							list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : undefined);
						}
						if (typeof method !== "function") method = list[method];
						return call.call(method, list, function (key, index) {
							if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
							return call.call(cb, thisArg, obj[key], key, obj, index);
						});
					};
				};
			},
			"assign": {
				"index.js": function (exports, module, require) {
					"use strict";

					module.exports = require("./is-implemented")()
						? Object.assign
						: require("./shim");
				},
				"is-implemented.js": function (exports, module, require) {
					"use strict";

					module.exports = function () {
						var assign = Object.assign, obj;
						if (typeof assign !== "function") return false;
						obj = { foo: "raz" };
						assign(obj, { bar: "dwa" }, { trzy: "trzy" });
						return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
					};
				},
				"shim.js": function (exports, module, require) {
					"use strict";

					var keys  = require("../keys")
					  , value = require("../valid-value")
					  , max   = Math.max;

					module.exports = function (dest, src /*, …srcn*/) {
						var error, i, length = max(arguments.length, 2), assign;
						dest = Object(value(dest));
						assign = function (key) {
							try {
								dest[key] = src[key];
							} catch (e) {
								if (!error) error = e;
							}
						};
						for (i = 1; i < length; ++i) {
							src = arguments[i];
							keys(src).forEach(assign);
						}
						if (error !== undefined) throw error;
						return dest;
					};
				}
			},
			"create.js": function (exports, module, require) {
				// Workaround for http://code.google.com/p/v8/issues/detail?id=2804

				"use strict";

				var create = Object.create, shim;

				if (!require("./set-prototype-of/is-implemented")()) {
					shim = require("./set-prototype-of/shim");
				}

				module.exports = (function () {
					var nullObject, polyProps, desc;
					if (!shim) return create;
					if (shim.level !== 1) return create;

					nullObject = {};
					polyProps = {};
					desc = {
						configurable: false,
						enumerable: false,
						writable: true,
						value: undefined
					};
					Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
						if (name === "__proto__") {
							polyProps[name] = {
								configurable: true,
								enumerable: false,
								writable: true,
								value: undefined
							};
							return;
						}
						polyProps[name] = desc;
					});
					Object.defineProperties(nullObject, polyProps);

					Object.defineProperty(shim, "nullPolyfill", {
						configurable: false,
						enumerable: false,
						writable: false,
						value: nullObject
					});

					return function (prototype, props) {
						return create(prototype === null ? nullObject : prototype, props);
					};
				}());
			},
			"for-each.js": function (exports, module, require) {
				"use strict";

				module.exports = require("./_iterate")("forEach");
			},
			"is-array-like.js": function (exports, module, require) {
				"use strict";

				var isFunction = require("../function/is-function")
				  , isObject   = require("./is-object")
				  , isValue    = require("./is-value");

				module.exports = function (value) {
					return (
						(isValue(value) &&
							typeof value.length === "number" &&
							// Just checking ((typeof x === 'object') && (typeof x !== 'function'))
							// won't work right for some cases, e.g.:
							// type of instance of NodeList in Safari is a 'function'
							((isObject(value) && !isFunction(value)) || typeof value === "string")) ||
						false
					);
				};
			},
			"is-callable.js": function (exports, module, require) {
				// Deprecated

				"use strict";

				module.exports = function (obj) {
				 return typeof obj === "function";
				};
			},
			"is-object.js": function (exports, module, require) {
				"use strict";

				var isValue = require("./is-value");

				var map = { function: true, object: true };

				module.exports = function (value) {
					return (isValue(value) && map[typeof value]) || false;
				};
			},
			"is-value.js": function (exports, module, require) {
				"use strict";

				var _undefined = require("../function/noop")(); // Support ES3 engines

				module.exports = function (val) {
				 return (val !== _undefined) && (val !== null);
				};
			},
			"keys": {
				"index.js": function (exports, module, require) {
					"use strict";

					module.exports = require("./is-implemented")()
						? Object.keys
						: require("./shim");
				},
				"is-implemented.js": function (exports, module, require) {
					"use strict";

					module.exports = function () {
						try {
							Object.keys("primitive");
							return true;
						} catch (e) {
					 return false;
					}
					};
				},
				"shim.js": function (exports, module, require) {
					"use strict";

					var isValue = require("../is-value");

					var keys = Object.keys;

					module.exports = function (object) {
						return keys(isValue(object) ? Object(object) : object);
					};
				}
			},
			"mixin.js": function (exports, module, require) {
				"use strict";

				var value = require("./valid-value")

				  , defineProperty = Object.defineProperty
				  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
				  , getOwnPropertyNames = Object.getOwnPropertyNames
				  , getOwnPropertySymbols = Object.getOwnPropertySymbols;

				module.exports = function (target, source) {
					var error, sourceObject = Object(value(source));
					target = Object(value(target));
					getOwnPropertyNames(sourceObject).forEach(function (name) {
						try {
							defineProperty(target, name, getOwnPropertyDescriptor(source, name));
						} catch (e) {
				 error = e;
				}
					});
					if (typeof getOwnPropertySymbols === "function") {
						getOwnPropertySymbols(sourceObject).forEach(function (symbol) {
							try {
								defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
							} catch (e) {
				 error = e;
				}
						});
					}
					if (error !== undefined) throw error;
					return target;
				};
			},
			"normalize-options.js": function (exports, module, require) {
				"use strict";

				var isValue = require("./is-value");

				var forEach = Array.prototype.forEach, create = Object.create;

				var process = function (src, obj) {
					var key;
					for (key in src) obj[key] = src[key];
				};

				// eslint-disable-next-line no-unused-vars
				module.exports = function (opts1 /*, …options*/) {
					var result = create(null);
					forEach.call(arguments, function (options) {
						if (!isValue(options)) return;
						process(Object(options), result);
					});
					return result;
				};
			},
			"set-prototype-of": {
				"index.js": function (exports, module, require) {
					"use strict";

					module.exports = require("./is-implemented")()
						? Object.setPrototypeOf
						: require("./shim");
				},
				"is-implemented.js": function (exports, module, require) {
					"use strict";

					var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};

					module.exports = function (/* CustomCreate*/) {
						var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
						if (typeof setPrototypeOf !== "function") return false;
						return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
					};
				},
				"shim.js": function (exports, module, require) {
					/* eslint no-proto: "off" */

					// Big thanks to @WebReflection for sorting this out
					// https://gist.github.com/WebReflection/5593554

					"use strict";

					var isObject        = require("../is-object")
					  , value           = require("../valid-value")
					  , objIsPrototypeOf = Object.prototype.isPrototypeOf
					  , defineProperty  = Object.defineProperty
					  , nullDesc        = {
						configurable: true,
						enumerable: false,
						writable: true,
						value: undefined
					}
					  , validate;

					validate = function (obj, prototype) {
						value(obj);
						if (prototype === null || isObject(prototype)) return obj;
						throw new TypeError("Prototype must be null or an object");
					};

					module.exports = (function (status) {
						var fn, set;
						if (!status) return null;
						if (status.level === 2) {
							if (status.set) {
								set = status.set;
								fn = function (obj, prototype) {
									set.call(validate(obj, prototype), prototype);
									return obj;
								};
							} else {
								fn = function (obj, prototype) {
									validate(obj, prototype).__proto__ = prototype;
									return obj;
								};
							}
						} else {
							fn = function self(obj, prototype) {
								var isNullBase;
								validate(obj, prototype);
								isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);
								if (isNullBase) delete self.nullPolyfill.__proto__;
								if (prototype === null) prototype = self.nullPolyfill;
								obj.__proto__ = prototype;
								if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
								return obj;
							};
						}
						return Object.defineProperty(fn, "level", {
							configurable: false,
							enumerable: false,
							writable: false,
							value: status.level
						});
					}(
						(function () {
							var tmpObj1 = Object.create(null)
							  , tmpObj2 = {}
							  , set
							  , desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

							if (desc) {
								try {
									set = desc.set; // Opera crashes at this point
									set.call(tmpObj1, tmpObj2);
								} catch (ignore) {}
								if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };
							}

							tmpObj1.__proto__ = tmpObj2;
							if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };

							tmpObj1 = {};
							tmpObj1.__proto__ = tmpObj2;
							if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };

							return false;
						})()
					));

					require("../create");
				}
			},
			"valid-callable.js": function (exports, module, require) {
				"use strict";

				module.exports = function (fn) {
					if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
					return fn;
				};
			},
			"valid-object.js": function (exports, module, require) {
				"use strict";

				var isObject = require("./is-object");

				module.exports = function (value) {
					if (!isObject(value)) throw new TypeError(value + " is not an Object");
					return value;
				};
			},
			"valid-value.js": function (exports, module, require) {
				"use strict";

				var isValue = require("./is-value");

				module.exports = function (value) {
					if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
					return value;
				};
			}
		},
		"string": {
			"#": {
				"contains": {
					"index.js": function (exports, module, require) {
						"use strict";

						module.exports = require("./is-implemented")()
							? String.prototype.contains
							: require("./shim");
					},
					"is-implemented.js": function (exports, module, require) {
						"use strict";

						var str = "razdwatrzy";

						module.exports = function () {
							if (typeof str.contains !== "function") return false;
							return (str.contains("dwa") === true) && (str.contains("foo") === false);
						};
					},
					"shim.js": function (exports, module, require) {
						"use strict";

						var indexOf = String.prototype.indexOf;

						module.exports = function (searchString/*, position*/) {
							return indexOf.call(this, searchString, arguments[1]) > -1;
						};
					}
				},
				"pad.js": function (exports, module, require) {
					"use strict";

					var toInteger = require("../../number/to-integer")
					  , value     = require("../../object/valid-value")
					  , repeat    = require("./repeat")

					  , abs = Math.abs, max = Math.max;

					module.exports = function (fill/*, length*/) {
						var self = String(value(this))
						  , sLength = self.length
						  , length = arguments[1];

						length = isNaN(length) ? 1 : toInteger(length);
						fill = repeat.call(String(fill), abs(length));
						if (length >= 0) return fill.slice(0, max(0, length - sLength)) + self;
						return self + ((sLength + length) >= 0 ? "" : fill.slice(length + sLength));
					};
				},
				"repeat": {
					"index.js": function (exports, module, require) {
						"use strict";

						module.exports = require("./is-implemented")()
							? String.prototype.repeat
							: require("./shim");
					},
					"is-implemented.js": function (exports, module, require) {
						"use strict";

						var str = "foo";

						module.exports = function () {
							if (typeof str.repeat !== "function") return false;
							return str.repeat(2) === "foofoo";
						};
					},
					"shim.js": function (exports, module, require) {
						// Thanks
						// @rauchma http://www.2ality.com/2014/01/efficient-string-repeat.html
						// @mathiasbynens https://github.com/mathiasbynens/String.prototype.repeat/blob/4a4b567def/repeat.js

						"use strict";

						var value     = require("../../../object/valid-value")
						  , toInteger = require("../../../number/to-integer");

						module.exports = function (count) {
							var str = String(value(this)), result;
							count = toInteger(count);
							if (count < 0) throw new RangeError("Count must be >= 0");
							if (!isFinite(count)) throw new RangeError("Count must be < ∞");

							result = "";
							while (count) {
								if (count % 2) result += str;
								if (count > 1) str += str;
								// eslint-disable-next-line no-bitwise
								count >>= 1;
							}
							return result;
						};
					}
				}
			},
			"is-string.js": function (exports, module, require) {
				"use strict";

				var objToString = Object.prototype.toString, id = objToString.call("");

				module.exports = function (value) {
					return (
						typeof value === "string" ||
						(value &&
							typeof value === "object" &&
							(value instanceof String || objToString.call(value) === id)) ||
						false
					);
				};
			}
		}
	},
	"es6-symbol": {
		"index.js": function (exports, module, require) {
			'use strict';

			module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');
		},
		"is-implemented.js": function (exports, module, require) {
			'use strict';

			var validTypes = { object: true, symbol: true };

			module.exports = function () {
				var symbol;
				if (typeof Symbol !== 'function') return false;
				symbol = Symbol('test symbol');
				try { String(symbol); } catch (e) { return false; }

				// Return 'true' also for polyfills
				if (!validTypes[typeof Symbol.iterator]) return false;
				if (!validTypes[typeof Symbol.toPrimitive]) return false;
				if (!validTypes[typeof Symbol.toStringTag]) return false;

				return true;
			};
		},
		"is-symbol.js": function (exports, module, require) {
			'use strict';

			module.exports = function (x) {
				if (!x) return false;
				if (typeof x === 'symbol') return true;
				if (!x.constructor) return false;
				if (x.constructor.name !== 'Symbol') return false;
				return (x[x.constructor.toStringTag] === 'Symbol');
			};
		},
		"polyfill.js": function (exports, module, require) {
			// ES2015 Symbol polyfill for environments that do not (or partially) support it

			'use strict';

			var d              = require('d')
			  , validateSymbol = require('./validate-symbol')

			  , create = Object.create, defineProperties = Object.defineProperties
			  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
			  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
			  , isNativeSafe;

			if (typeof Symbol === 'function') {
				NativeSymbol = Symbol;
				try {
					String(NativeSymbol());
					isNativeSafe = true;
				} catch (ignore) {}
			}

			var generateName = (function () {
				var created = create(null);
				return function (desc) {
					var postfix = 0, name, ie11BugWorkaround;
					while (created[desc + (postfix || '')]) ++postfix;
					desc += (postfix || '');
					created[desc] = true;
					name = '@@' + desc;
					defineProperty(objPrototype, name, d.gs(null, function (value) {
						// For IE11 issue see:
						// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
						//    ie11-broken-getters-on-dom-objects
						// https://github.com/medikoo/es6-symbol/issues/12
						if (ie11BugWorkaround) return;
						ie11BugWorkaround = true;
						defineProperty(this, name, d(value));
						ie11BugWorkaround = false;
					}));
					return name;
				};
			}());

			// Internal constructor (not one exposed) for creating Symbol instances.
			// This one is used to ensure that `someSymbol instanceof Symbol` always return false
			HiddenSymbol = function Symbol(description) {
				if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
				return SymbolPolyfill(description);
			};

			// Exposed `Symbol` constructor
			// (returns instances of HiddenSymbol)
			module.exports = SymbolPolyfill = function Symbol(description) {
				var symbol;
				if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
				if (isNativeSafe) return NativeSymbol(description);
				symbol = create(HiddenSymbol.prototype);
				description = (description === undefined ? '' : String(description));
				return defineProperties(symbol, {
					__description__: d('', description),
					__name__: d('', generateName(description))
				});
			};
			defineProperties(SymbolPolyfill, {
				for: d(function (key) {
					if (globalSymbols[key]) return globalSymbols[key];
					return (globalSymbols[key] = SymbolPolyfill(String(key)));
				}),
				keyFor: d(function (s) {
					var key;
					validateSymbol(s);
					for (key in globalSymbols) if (globalSymbols[key] === s) return key;
				}),

				// To ensure proper interoperability with other native functions (e.g. Array.from)
				// fallback to eventual native implementation of given symbol
				hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
				isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
					SymbolPolyfill('isConcatSpreadable')),
				iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
				match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
				replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
				search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
				species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
				split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
				toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
				toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
				unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
			});

			// Internal tweaks for real symbol producer
			defineProperties(HiddenSymbol.prototype, {
				constructor: d(SymbolPolyfill),
				toString: d('', function () { return this.__name__; })
			});

			// Proper implementation of methods exposed on Symbol.prototype
			// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
			defineProperties(SymbolPolyfill.prototype, {
				toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
				valueOf: d(function () { return validateSymbol(this); })
			});
			defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
				var symbol = validateSymbol(this);
				if (typeof symbol === 'symbol') return symbol;
				return symbol.toString();
			}));
			defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

			// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
			defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
				d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

			// Note: It's important to define `toPrimitive` as last one, as some implementations
			// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
			// And that may invoke error in definition flow:
			// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
			defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
				d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
		},
		"validate-symbol.js": function (exports, module, require) {
			'use strict';

			var isSymbol = require('./is-symbol');

			module.exports = function (value) {
				if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
				return value;
			};
		}
	},
	"event-emitter": {
		"index.js": function (exports, module, require) {
			'use strict';

			var d        = require('d')
			  , callable = require('es5-ext/object/valid-callable')

			  , apply = Function.prototype.apply, call = Function.prototype.call
			  , create = Object.create, defineProperty = Object.defineProperty
			  , defineProperties = Object.defineProperties
			  , hasOwnProperty = Object.prototype.hasOwnProperty
			  , descriptor = { configurable: true, enumerable: false, writable: true }

			  , on, once, off, emit, methods, descriptors, base;

			on = function (type, listener) {
				var data;

				callable(listener);

				if (!hasOwnProperty.call(this, '__ee__')) {
					data = descriptor.value = create(null);
					defineProperty(this, '__ee__', descriptor);
					descriptor.value = null;
				} else {
					data = this.__ee__;
				}
				if (!data[type]) data[type] = listener;
				else if (typeof data[type] === 'object') data[type].push(listener);
				else data[type] = [data[type], listener];

				return this;
			};

			once = function (type, listener) {
				var once, self;

				callable(listener);
				self = this;
				on.call(this, type, once = function () {
					off.call(self, type, once);
					apply.call(listener, this, arguments);
				});

				once.__eeOnceListener__ = listener;
				return this;
			};

			off = function (type, listener) {
				var data, listeners, candidate, i;

				callable(listener);

				if (!hasOwnProperty.call(this, '__ee__')) return this;
				data = this.__ee__;
				if (!data[type]) return this;
				listeners = data[type];

				if (typeof listeners === 'object') {
					for (i = 0; (candidate = listeners[i]); ++i) {
						if ((candidate === listener) ||
								(candidate.__eeOnceListener__ === listener)) {
							if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
							else listeners.splice(i, 1);
						}
					}
				} else {
					if ((listeners === listener) ||
							(listeners.__eeOnceListener__ === listener)) {
						delete data[type];
					}
				}

				return this;
			};

			emit = function (type) {
				var i, l, listener, listeners, args;

				if (!hasOwnProperty.call(this, '__ee__')) return;
				listeners = this.__ee__[type];
				if (!listeners) return;

				if (typeof listeners === 'object') {
					l = arguments.length;
					args = new Array(l - 1);
					for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

					listeners = listeners.slice();
					for (i = 0; (listener = listeners[i]); ++i) {
						apply.call(listener, this, args);
					}
				} else {
					switch (arguments.length) {
					case 1:
						call.call(listeners, this);
						break;
					case 2:
						call.call(listeners, this, arguments[1]);
						break;
					case 3:
						call.call(listeners, this, arguments[1], arguments[2]);
						break;
					default:
						l = arguments.length;
						args = new Array(l - 1);
						for (i = 1; i < l; ++i) {
							args[i - 1] = arguments[i];
						}
						apply.call(listeners, this, args);
					}
				}
			};

			methods = {
				on: on,
				once: once,
				off: off,
				emit: emit
			};

			descriptors = {
				on: d(on),
				once: d(once),
				off: d(off),
				emit: d(emit)
			};

			base = defineProperties({}, descriptors);

			module.exports = exports = function (o) {
				return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
			};
			exports.methods = methods;
		},
		"unify.js": function (exports, module, require) {
			'use strict';

			var forEach    = require('es5-ext/object/for-each')
			  , validValue = require('es5-ext/object/valid-object')

			  , push = Array.prototype.apply, defineProperty = Object.defineProperty
			  , create = Object.create, hasOwnProperty = Object.prototype.hasOwnProperty
			  , d = { configurable: true, enumerable: false, writable: true };

			module.exports = function (e1, e2) {
				var data;
				(validValue(e1) && validValue(e2));
				if (!hasOwnProperty.call(e1, '__ee__')) {
					if (!hasOwnProperty.call(e2, '__ee__')) {
						d.value = create(null);
						defineProperty(e1, '__ee__', d);
						defineProperty(e2, '__ee__', d);
						d.value = null;
						return;
					}
					d.value = e2.__ee__;
					defineProperty(e1, '__ee__', d);
					d.value = null;
					return;
				}
				data = d.value = e1.__ee__;
				if (!hasOwnProperty.call(e2, '__ee__')) {
					defineProperty(e2, '__ee__', d);
					d.value = null;
					return;
				}
				if (data === e2.__ee__) return;
				forEach(e2.__ee__, function (listener, name) {
					if (!data[name]) {
						data[name] = listener;
						return;
					}
					if (typeof data[name] === 'object') {
						if (typeof listener === 'object') push.apply(data[name], listener);
						else data[name].push(listener);
					} else if (typeof listener === 'object') {
						listener.unshift(data[name]);
						data[name] = listener;
					} else {
						data[name] = [data[name], listener];
					}
				});
				defineProperty(e2, '__ee__', d);
				d.value = null;
			};
		}
	},
	"next-tick": {
		"index.js": function (exports, module, require) {
			'use strict';

			var callable, byObserver;

			callable = function (fn) {
				if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
				return fn;
			};

			byObserver = function (Observer) {
				var node = document.createTextNode(''), queue, currentQueue, i = 0;
				new Observer(function () {
					var callback;
					if (!queue) {
						if (!currentQueue) return;
						queue = currentQueue;
					} else if (currentQueue) {
						queue = currentQueue.concat(queue);
					}
					currentQueue = queue;
					queue = null;
					if (typeof currentQueue === 'function') {
						callback = currentQueue;
						currentQueue = null;
						callback();
						return;
					}
					node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
					while (currentQueue) {
						callback = currentQueue.shift();
						if (!currentQueue.length) currentQueue = null;
						callback();
					}
				}).observe(node, { characterData: true });
				return function (fn) {
					callable(fn);
					if (queue) {
						if (typeof queue === 'function') queue = [queue, fn];
						else queue.push(fn);
						return;
					}
					queue = fn;
					node.data = (i = ++i % 2);
				};
			};

			module.exports = (function () {
				// Node.js
				if ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {
					return process.nextTick;
				}

				// MutationObserver
				if ((typeof document === 'object') && document) {
					if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
					if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
				}

				// W3C Draft
				// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
				if (typeof setImmediate === 'function') {
					return function (cb) { setImmediate(callable(cb)); };
				}

				// Wide available standard
				if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
					return function (cb) { setTimeout(callable(cb), 0); };
				}

				return null;
			}());
		}
	},
	"timers-ext": {
		"max-timeout.js": function (exports, module, require) {
			'use strict';

			module.exports = 2147483647;
		},
		"valid-timeout.js": function (exports, module, require) {
			'use strict';

			var toPosInt   = require('es5-ext/number/to-pos-integer')
			  , maxTimeout = require('./max-timeout');

			module.exports = function (value) {
				value = toPosInt(value);
				if (value > maxTimeout) throw new TypeError(value + " exceeds maximum possible timeout");
				return value;
			};
		}
	}
})("deferred/index");
